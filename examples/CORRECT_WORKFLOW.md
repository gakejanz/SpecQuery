# Correct SpecQuery + openapi-typescript Workflow

## The Problem We Fixed

The original approach was **backwards**. We were trying to generate OpenAPI specs from openapi-typescript, but openapi-typescript generates **types FROM OpenAPI specs**, not the other way around.

## âœ… Correct Workflow

### 1. Start with OpenAPI Spec
You need an OpenAPI 3.x specification file (YAML or JSON).

### 2. Generate Types with openapi-typescript
```bash
# From YAML spec
npx openapi-typescript petstore.yaml -o src/api/types.ts

# From JSON spec  
npx openapi-typescript petstore.json -o src/api/types.ts

# From remote URL
npx openapi-typescript https://api.example.com/openapi.json -o src/api/types.ts
```

This generates comprehensive TypeScript types from your OpenAPI spec.

### 3. Generate React Query Hooks with SpecQuery
```bash
# From YAML spec
npx spec-query \
  --schema petstore.yaml \
  --out src/hooks \
  --openapi-ts-config openapi-ts.config.json \
  --generate-types

# From JSON spec
npx spec-query \
  --schema petstore.json \
  --out src/hooks \
  --openapi-ts-config openapi-ts.config.json \
  --generate-types
```

This generates React Query hooks that integrate with the openapi-typescript types.

## ðŸ”§ Key Adjustments Made

### 1. **Removed Client Generation from openapi-ts integration**
- openapi-typescript only generates types, not HTTP clients
- SpecQuery provides the HTTP client functionality

### 2. **Updated Configuration**
```json
// openapi-ts.config.json
{
  "typesPath": "./src/api/types.ts",  // Path to openapi-typescript generated types
  "baseUrl": "https://api.example.com",
  "headers": {
    "Authorization": "Bearer {{token}}"
  }
}
```

### 3. **Correct Integration Pattern**
```typescript
// Generated hooks import types from openapi-typescript
import type { paths } from '../api/types';

// Use the types in your components
type Pet = paths['/pets']['get']['responses']['200']['content']['application/json'][0];
type CreatePetRequest = paths['/pets']['post']['requestBody']['content']['application/json'];
```

## ðŸ“ Generated File Structure

```
src/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ types.ts           # Generated by openapi-typescript
â”œâ”€â”€ hooks/                 # Generated by SpecQuery
â”‚   â”œâ”€â”€ client.ts          # HTTP client with error handling
â”‚   â”œâ”€â”€ queryKeys.ts       # Query keys for cache management
â”‚   â”œâ”€â”€ invalidate.ts      # Query invalidation utilities
â”‚   â”œâ”€â”€ types.ts           # Additional SpecQuery types
â”‚   â””â”€â”€ hooks/
â”‚       â””â”€â”€ Pets.generated.ts  # React Query hooks
â””â”€â”€ components/
    â””â”€â”€ PetList.tsx        # Your React components
```

## ðŸš€ Usage Example

```typescript
import { useGetPets, useCreatePet } from '../hooks/hooks/Pets.generated';
import type { paths } from '../api/types';

// Use openapi-typescript types
type Pet = paths['/pets']['get']['responses']['200']['content']['application/json'][0];
type CreatePetRequest = paths['/pets']['post']['requestBody']['content']['application/json'];

function PetList() {
  const { data: pets, isLoading, error } = useGetPets({
    query: { status: ['available'], limit: 10 }
  });

  const createPet = useCreatePet({
    onSuccess: (data: Pet) => {
      console.log('Pet created:', data);
    }
  });

  const handleCreate = (petData: CreatePetRequest) => {
    createPet.mutate(petData);
  };

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {pets?.map(pet => (
        <div key={pet.id}>{pet.name}</div>
      ))}
    </div>
  );
}
```

## ðŸŽ¯ Benefits of This Approach

1. **Type Safety**: Full TypeScript support with generated interfaces
2. **Separation of Concerns**: openapi-typescript handles types, SpecQuery handles React Query
3. **Developer Experience**: IntelliSense, autocomplete, and compile-time error checking
4. **Maintainability**: Clean separation between type generation and hook generation
5. **Flexibility**: Can use openapi-typescript types independently of SpecQuery hooks

## ðŸ”„ Development Workflow

1. **Update OpenAPI spec** when API changes
2. **Regenerate types**: `npx openapi-typescript spec.yaml -o src/api/types.ts`
3. **Regenerate hooks**: `npx spec-query --schema spec.yaml --out src/hooks --openapi-ts-config config.json`
4. **Update components** to use new types and hooks

## ðŸ›  Configuration Options

### SpecQuery CLI Options
```bash
npx spec-query \
  --schema petstore.yaml \           # OpenAPI spec file
  --out src/hooks \                   # Output directory
  --openapi-ts-config config.json \   # openapi-typescript config
  --generate-types \                  # Generate additional types
  --base-url https://api.example.com # API base URL
  --group-by-tag                     # Group hooks by OpenAPI tags
```

### openapi-typescript Options
```bash
npx openapi-typescript \
  petstore.yaml \                    # OpenAPI spec file
  -o src/api/types.ts \              # Output file
  --transform \                      # Transform function
  --default-non-nullable \           # Make all properties non-nullable
  --export-type \                    # Export specific types
```

## ðŸš¨ Common Pitfalls to Avoid

1. **Don't try to generate OpenAPI specs from openapi-typescript** - it only generates types
2. **Don't mix up the order** - always generate types first, then hooks
3. **Don't forget to update both** when your API changes
4. **Don't hardcode types** - always use the generated types from openapi-typescript

## ðŸ“š Additional Resources

- [openapi-typescript Documentation](https://openapi-ts.dev)
- [TanStack Query Documentation](https://tanstack.com/query)
- [OpenAPI Specification](https://swagger.io/specification/)
